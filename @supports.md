## ✔️ @supports 
 ---<br/>title: '@supports'<br/>slug: Web/CSS/@supports<br/>tags:<br/>  - At-rule<br/>  - CSS<br/>  - Layout<br/>  - Reference<br/>  - Web<br/>  - supports<br/>browser-compat: css.at-rules.supports<br/>---<br/>{{CSSRef}}<br/><br/>The **`@supports`** [CSS](/en-US/docs/Web/CSS) [at-rule](/en-US/docs/Web/CSS/At-rule) lets you specify declarations that depend on a browser's support for one or more specific CSS features. This is called a _feature query_. The rule may be placed at the top level of your code or nested inside any other [conditional group at-rule](/en-US/docs/Web/CSS/At-rule#conditional_group_rules).<br/><br/>```css<br/>@supports (display: grid) {<br/>  div {<br/>    display: grid;<br/>  }<br/>}<br/>```<br/><br/>```css<br/>@supports not (display: grid) {<br/>  div {<br/>    float: right;<br/>  }<br/>}<br/>```<br/><br/>In JavaScript, `@supports` can be accessed via the CSS object model interface {{DOMxRef(CSSSupportsRule)}}.<br/><br/>## Syntax<br/><br/>The `@supports` at-rule associates a block of statements with a _supports condition._ The supports condition consists of one or more name-value pairs combined by conjunctions (`and`), disjunctions (`or`), and/or negations (`not`). Precedence of operators can be defined with parentheses.<br/><br/>### Declaration syntax<br/><br/>The most basic supports condition is a simple declaration (a property name followed by a value, separated by a colon). The declaration must be surrounded by parentheses. The following example returns true if the browser's {{CSSxRef(transform-origin)}} property considers `5% 5%` valid:<br/><br/>```css<br/>@supports (transform-origin: 5% 5%) {}<br/>```<br/><br/>### Function syntax<br/><br/>The second basic supports condition is a supports function, the syntax for these is supported by all browsers, but the functions themselves are still being standardized.<br/><br/>#### `selector()` {{Experimental_Inline}}<br/><br/>Tests if the browser supports the tested selector syntax. The following example returns true if the browser supports the [child combinator](/en-US/docs/Web/CSS/Child_combinator):<br/><br/>```css<br/>@supports selector(A > B) {}<br/>```<br/><br/>### The not operator<br/><br/>The `not` operator can precede any expression to create a new expression, resulting in the negation of the original one. The following example returns true if the browser's {{CSSxRef(transform-origin)}} property **doesn't** consider `10em 10em 10em` valid:<br/><br/>```css<br/>@supports not (transform-origin: 10em 10em 10em) {}<br/>```<br/><br/>As with any operator, the `not` operator can be applied to a declaration of any complexity. The following examples are both valid:<br/><br/>```css<br/>@supports not (not (transform-origin: 2px)) {}<br/>@supports (display: grid) and (not (display: inline-grid)) {}<br/>```<br/><br/>> **Note:** There is no need to enclose the `not` operator between two parentheses at the top level. To combine it with other operators, like `and` and `or`, the parentheses are required.<br/><br/>### The and operator<br/><br/>The `and` operator creates a new expression from the conjunction of two shorter expressions. It returns true only if **both** of the shorter expressions are also true. The following example returns true if and only if the two shorter expressions are simultaneously true:<br/><br/>```css<br/>@supports (display: table-cell) and (display: list-item) {}<br/>```<br/><br/>Multiple conjunctions can be juxtaposed without the need of more parentheses. The following are both equivalent:<br/><br/>```css<br/>@supports (display: table-cell) and (display: list-item) and (display:contents) {}<br/>@supports (display: table-cell) and ((display: list-item) and (display:contents)) {}<br/>```<br/><br/>### The or operator<br/><br/>The `or` operator creates a new expression from the disjunction of two shorter expressions. It returns true if **one or both** of the shorter expressions is also true. The following example returns true if at least one of the two shorter expressions is true:<br/><br/>```css<br/>@supports (transform-style: preserve) or (-moz-transform-style: preserve) {}<br/>```<br/><br/>Multiple disjunctions can be juxtaposed without the need of more parentheses. The following are both equivalent:<br/><br/>```css<br/>@supports (transform-style: preserve) or (-moz-transform-style: preserve) or<br/>          (-o-transform-style: preserve) or (-webkit-transform-style: preserve) {}<br/><br/>@supports (transform-style: preserve-3d) or ((-moz-transform-style: preserve-3d) or<br/>          ((-o-transform-style: preserve-3d) or (-webkit-transform-style: preserve-3d))) {}<br/>```<br/><br/>> **Note:** When using both `and` and `or` operators, the parentheses must be used to define the order in which they apply. Otherwise, the condition is invalid and the whole rule is ignored.<br/><br/>## Formal syntax<br/><br/>{{CSSSyntax}}<br/><br/>## Examples<br/><br/>### Testing for the support of a given CSS property<br/><br/>```css<br/>@supports (animation-name: test) {<br/>  … /* CSS applied when animations are supported without a prefix */<br/>  @keyframes { /* Other at-rules can be nested inside */<br/>    …<br/>  }<br/>}<br/>```<br/><br/>### Testing for the support of a given CSS property or a prefixed version<br/><br/>```css<br/>@supports ((perspective: 10px) or (-moz-perspective: 10px) or (-webkit-perspective: 10px) or<br/>         (-ms-perspective: 10px) or (-o-perspective: 10px)) {<br/>  … /* CSS applied when 3D transforms, prefixed or not, are supported */<br/>}<br/>```<br/><br/>### Testing for the non-support of a specific CSS property<br/><br/>```css<br/>@supports not ((text-align-last: justify) or (-moz-text-align-last: justify)) {<br/>  … /* CSS to provide fallback alternative for text-align-last: justify */<br/>}<br/>```<br/><br/>### Testing for the support of custom properties<br/><br/>```css<br/>@supports (--foo: green) {<br/>  body {<br/>    color: var(--varName);<br/>  }<br/>}<br/>```<br/><br/>### Testing for the support of a selector<br/><br/>The CSS Conditional Rules Level 4 specification adds the ability to test for support of a selector—for example {{cssxref(:is,:is())}}.<br/><br/>```css<br/>/* This rule won't be applied in browsers which don't support :is() */<br/>:is(ul, ol) > li {<br/>  … /* CSS applied when the :is(…) selector is supported */<br/>}<br/><br/>@supports not selector(:is(a, b)) {<br/>  /* Fallback for when :is() is unsupported */<br/>  ul > li,<br/>  ol > li {<br/>    … /* The above expanded for browsers which don't support :is(…) */<br/>  }<br/>}<br/><br/>/* Note: So far, there's no browser that supports the `of` argument of :nth-child(…) */<br/>@supports selector(:nth-child(1n of a, b)) {<br/>  /* This rule needs to be inside the @supports block, otherwise<br/>     it will be partially applied in browsers which don't support<br/>     the `of` argument of :nth-child(…) */<br/>  :is(<br/>      :nth-child(1n of ul, ol) a,<br/>      details > summary<br/>  ) {<br/>    … /* CSS applied when the :is(…) selector and<br/>         the `of` argument of :nth-child(…) are both supported */<br/>  }<br/>}<br/>```<br/><br/>## Specifications<br/><br/>{{Specifications}}<br/><br/>## Browser compatibility<br/><br/>{{Compat}}<br/><br/>## See also<br/><br/>- [Using feature queries](/en-US/docs/Web/CSS/CSS_Conditional_Rules/Using_Feature_Queries)<br/>- The CSSOM class {{DOMxRef(CSSSupportsRule)}}, and the {{DOMxRef(CSS.supports())}} method that allows the same check to be performed via JavaScript.<br/>